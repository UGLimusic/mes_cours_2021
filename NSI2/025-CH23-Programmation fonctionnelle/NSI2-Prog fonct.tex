\documentclass[a4paper,12pt,french]{article}
\usepackage[margin=2cm]{geometry}
\usepackage[thinfonts,latinmath]{uglix2}
\nouveaustyle
\begin{document}
\titre{Programmation fonctionnelle}{NSI2}{02/2022}

\begin{exercice}[ : appliquer une fonction à une liste]
	\'Ecrire une fonction \pythoninline{apply} qui
\begin{enumerate}[--]
	\item 	en entrée prend une fonction \pythoninline{f(x : float) -> float} et \pythoninline{l} une liste de \pythoninline{float};
	\item 	renvoie la liste dont les éléments sont les images des éléments de \pythoninline{l} par \pythoninline{f}, dans le même ordre.
\end{enumerate}
\textbf{Exemple d'utilisation :}
\begin{minted}{python}
def f(x):
    return 2 * x + 1


print(apply(f, [1, 2, 3]))  # [3, 5, 7]
\end{minted}

\end{exercice}

\begin{exercice}[ : vérification d'une propriété]
	On considère une fonction \pythoninline{p} qui
	\begin{enumerate}[--]
		\item 	en entrée prend un \pythoninline{int x};
		\item 	en sortie renvoie \pythoninline{True} ou \pythoninline{False} selon que \pythoninline{x} vérifie ou non une certaine propriété (être pair, être premier, être compris entre 1 et 100, \textit{et c\ae tera).})
	\end{enumerate}
	\'Ecrire une fonction \pythoninline{verify} qui
\begin{enumerate}[--]
	\item 	en entrée prend \pythoninline{p} une fonction comme spécifié plus haut et \texttt{l} une liste d'\pythoninline{int};
	\item 	en sortie renvoie
		\begin{enumerate}[--]
			\item 	le premier élément \pythoninline{x} de \pythoninline{l} tel que \pythoninline{p(x)} vaut \pythoninline{True} s'il y en a un;
			\item 	\pythoninline{None} s'il n'y en a pas.	
		\end{enumerate} 
\end{enumerate}
\textbf{Exemple d'utilisation :}
\begin{minted}{python}
def p(x: int) -> bool:
    return x % 10 == 2


print(verify(p, [1, 3, 293, 202, 14]))
\end{minted}
\end{exercice}

\begin{exercice}[ : équation réduite de droite]
	\'Ecrire une fonction \pythoninline{affine_function2} qui 
\begin{enumerate}[--]
	\item 	en entrée prend quatre \pythoninline{float xA, yA, xB, yB} qui sont les coordonnées de deux points $A$ et $B$ dans un repère du plan;
	\item 	en sortie renvoie 
	\begin{enumerate}[--]
		\item 	\pythoninline{None} si \pythoninline{xA} et \pythoninline{xB} sont égaux ;
		\item 	la fonction affine dont la représentation graphique est la droite $(AB)$ sinon.
	\end{enumerate}
\end{enumerate}
\textbf{Exemple d'utilisation :}
\begin{minted}{python}
f = affine_function2(0, 2, 1, 5)  # points sur y = 3 * x + 2
print(f(4))  # 14
\end{minted}
\end{exercice}

\begin{exercice}[ : composée de deux fonctions]
	\'Ecrire une fonction \pythoninline{compose} qui 
\begin{enumerate}[--]
	\item 	en entrée prend deux fonctions \pythoninline{f} et \pythoninline{g} qui représentent deux fonctions de $\R$ dans $\R$;
	\item 	en sortie renvoie la fonction qui correspond à l'enchaînement de \pythoninline{g} puis de \pythoninline{f}, c'est à dire à la fonction qui à tout \pythoninline{float x}  associe \pythoninline{f(g(x)))}.
\end{enumerate}
\textbf{Exemple d'utilisation :}
\begin{minted}{python}
def u(x):
    return x + 1


def v(x):
    return 2 * x


w = compose(u, v)  # w(x) = u(v(x)) = u(2x) = 2x + 1

print(w(4))  # 2*4 + 1 = 9
\end{minted}

\end{exercice}

\begin{exercice}[]
	\'Ecrire une fonction \pythoninline{evaluate_with_delay} qui 
	\begin{enumerate}[--]
		\item 	en entrée prend fonction \pythoninline{f(x : float )-> float}, un \pythoninline{int n} et un \texttt{float d}; 
		\item 	en sortie affiche les résultats \pythoninline{f(0)}, \pythoninline{f(1)}, ..., \pythoninline{f(n-1)} en faisant une pause de \pythoninline{d} millisecondes entre chaque affichage.
	\end{enumerate}
On pourra utiliser la fonction \pythoninline{sleep} du module \pythoninline{time} de \textsc{Python} : \pythoninline{sleep(t : float)} met le programme en pause pendant \pythoninline{t} secondes.\\
\textbf{Exemple d'utilisation :}
\begin{minted}{python}
evaluate_with_delay(lambda x: x * 2, 10, 1000) 
# affiche 0 2 4 6 8 10 12 14 16 18  seconde par seconde
\end{minted}
\end{exercice}

\begin{exercice}[ : mesurer le temps d'exécution d'une fonction]
	\'Ecrire une fonction \pythoninline{get_execution_time} qui
\begin{enumerate}[--]
	\item 	en entrée prend une fonction \pythoninline{f(x : int)} et un \pythoninline{int x};
	\item 	en sortie renvoie le temps nécessaire à l'exécution (évaluation) de \pythoninline{f(x)} en millisecondes.
\end{enumerate}
On pourra utiliser la la fonction \pythoninline{perf_counter} du module \pythoninline{time} qui indique combien de millisecondes se sont écoulées depuis le lancement d'un programme \textsc{Python}.\\


\textbf{Exemple d'utilisation :}
\begin{minted}{python}
duration = get_execution_time(sum_first_int, 10**8)
print(f"Duration : {duration} milliseconds.")
# affiche Duration : 5.8542724999999995 milliseconds.
\end{minted}
\end{exercice}
\end{document}
